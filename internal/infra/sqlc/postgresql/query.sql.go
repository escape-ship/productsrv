// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package postgresql

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getCategories = `-- name: GetCategories :many
SELECT id, name
FROM products.categories
`

func (q *Queries) GetCategories(ctx context.Context) ([]ProductsCategory, error) {
	rows, err := q.db.QueryContext(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsCategory
	for rows.Next() {
		var i ProductsCategory
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesByProductID = `-- name: GetCategoriesByProductID :many
SELECT c.id, c.name
FROM products.categories c
JOIN products.product_categories pc ON c.id = pc.category_id
WHERE pc.product_id = $1
`

func (q *Queries) GetCategoriesByProductID(ctx context.Context, productID uuid.UUID) ([]ProductsCategory, error) {
	rows, err := q.db.QueryContext(ctx, getCategoriesByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsCategory
	for rows.Next() {
		var i ProductsCategory
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name
FROM products.categories
WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id int32) (ProductsCategory, error) {
	row := q.db.QueryRowContext(ctx, getCategoryByID, id)
	var i ProductsCategory
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, name, price, image_url, created_at, updated_at
FROM products.product
WHERE id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (ProductsProduct, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i ProductsProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByName = `-- name: GetProductByName :one
SELECT id, name, price, image_url, created_at, updated_at
FROM products.product
WHERE name = $1
`

func (q *Queries) GetProductByName(ctx context.Context, name string) (ProductsProduct, error) {
	row := q.db.QueryRowContext(ctx, getProductByName, name)
	var i ProductsProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductCustomOptionValues = `-- name: GetProductCustomOptionValues :many
SELECT
  o.id AS option_id,
  o.name AS option_name,
  ov.id AS value_id,
  ov.value AS value
FROM products.product_option_values pov
JOIN products.option_values ov ON pov.option_value_id = ov.id
JOIN products.options o ON pov.option_id = o.id
WHERE pov.product_id = $1
ORDER BY o.id, ov.id
`

type GetProductCustomOptionValuesRow struct {
	OptionID   int32  `json:"option_id"`
	OptionName string `json:"option_name"`
	ValueID    int32  `json:"value_id"`
	Value      string `json:"value"`
}

func (q *Queries) GetProductCustomOptionValues(ctx context.Context, productID uuid.UUID) ([]GetProductCustomOptionValuesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductCustomOptionValues, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductCustomOptionValuesRow
	for rows.Next() {
		var i GetProductCustomOptionValuesRow
		if err := rows.Scan(
			&i.OptionID,
			&i.OptionName,
			&i.ValueID,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductDefaultOptionValues = `-- name: GetProductDefaultOptionValues :many
SELECT
  o.id AS option_id,
  o.name AS option_name,
  ov.id AS value_id,
  ov.value AS value
FROM products.product_categories pc
JOIN products.category_options co ON pc.category_id = co.category_id
JOIN products.options o ON co.option_id = o.id
JOIN products.option_values ov ON ov.option_id = o.id
WHERE pc.product_id = $1
ORDER BY o.id, ov.id
`

type GetProductDefaultOptionValuesRow struct {
	OptionID   int32  `json:"option_id"`
	OptionName string `json:"option_name"`
	ValueID    int32  `json:"value_id"`
	Value      string `json:"value"`
}

func (q *Queries) GetProductDefaultOptionValues(ctx context.Context, productID uuid.UUID) ([]GetProductDefaultOptionValuesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductDefaultOptionValues, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductDefaultOptionValuesRow
	for rows.Next() {
		var i GetProductDefaultOptionValuesRow
		if err := rows.Scan(
			&i.OptionID,
			&i.OptionName,
			&i.ValueID,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, price, image_url, created_at, updated_at
FROM products.product
`

func (q *Queries) GetProducts(ctx context.Context) ([]ProductsProduct, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsProduct
	for rows.Next() {
		var i ProductsProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasProductCustomOptionValues = `-- name: HasProductCustomOptionValues :one
SELECT EXISTS (
  SELECT 1
  FROM products.product_option_values
  WHERE product_id = $1
) AS has_custom
`

func (q *Queries) HasProductCustomOptionValues(ctx context.Context, productID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasProductCustomOptionValues, productID)
	var has_custom bool
	err := row.Scan(&has_custom)
	return has_custom, err
}

const postProducts = `-- name: PostProducts :exec
INSERT INTO products.product (id, name, price, image_url)
VALUES ($1, $2, $3, $4)
`

type PostProductsParams struct {
	ID       uuid.UUID      `json:"id"`
	Name     string         `json:"name"`
	Price    int64          `json:"price"`
	ImageUrl sql.NullString `json:"image_url"`
}

func (q *Queries) PostProducts(ctx context.Context, arg PostProductsParams) error {
	_, err := q.db.ExecContext(ctx, postProducts,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.ImageUrl,
	)
	return err
}
