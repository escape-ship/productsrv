// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package postgresql

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const decrementStockQuantities = `-- name: DecrementStockQuantities :exec
UPDATE products.inventories
SET stock_quantity = stock_quantity - 1
WHERE id = ANY($1::uuid[])
`

func (q *Queries) DecrementStockQuantities(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, decrementStockQuantities, pq.Array(dollar_1))
	return err
}

const getInventoriesByProductID = `-- name: GetInventoriesByProductID :many
SELECT id, product_id, product_option_id, stock_quantity
FROM products.inventories
WHERE product_id = $1
`

func (q *Queries) GetInventoriesByProductID(ctx context.Context, productID uuid.UUID) ([]ProductsInventory, error) {
	rows, err := q.db.QueryContext(ctx, getInventoriesByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsInventory
	for rows.Next() {
		var i ProductsInventory
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductOptionID,
			&i.StockQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryByProductID = `-- name: GetInventoryByProductID :one
SELECT product_id, stock_quantity
FROM products.inventories
WHERE product_id = $1
`

type GetInventoryByProductIDRow struct {
	ProductID     uuid.UUID `json:"product_id"`
	StockQuantity int32     `json:"stock_quantity"`
}

func (q *Queries) GetInventoryByProductID(ctx context.Context, productID uuid.UUID) (GetInventoryByProductIDRow, error) {
	row := q.db.QueryRowContext(ctx, getInventoryByProductID, productID)
	var i GetInventoryByProductIDRow
	err := row.Scan(&i.ProductID, &i.StockQuantity)
	return i, err
}

const getProductByName = `-- name: GetProductByName :one
SELECT p.id, p.name, p.price, p.image_url, p.created_at, p.updated_at,
       COALESCE(json_agg(DISTINCT c.name) FILTER (WHERE c.id IS NOT NULL), '[]') AS categories,
       COALESCE(SUM(i.stock_quantity), 0) AS inventory
FROM products.product p
LEFT JOIN products.products_categories_relations pcr ON p.id = pcr.product_id
LEFT JOIN products.categories c ON pcr.category_id = c.id
LEFT JOIN products.inventories i ON p.id = i.product_id
WHERE p.name = $1
GROUP BY p.id
`

type GetProductByNameRow struct {
	ID         uuid.UUID      `json:"id"`
	Name       string         `json:"name"`
	Price      int64          `json:"price"`
	ImageUrl   sql.NullString `json:"image_url"`
	CreatedAt  sql.NullTime   `json:"created_at"`
	UpdatedAt  sql.NullTime   `json:"updated_at"`
	Categories interface{}    `json:"categories"`
	Inventory  interface{}    `json:"inventory"`
}

func (q *Queries) GetProductByName(ctx context.Context, name string) (GetProductByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByName, name)
	var i GetProductByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Categories,
		&i.Inventory,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT p.id, p.name, p.price, p.image_url, p.created_at, p.updated_at,
       COALESCE(json_agg(DISTINCT c.name) FILTER (WHERE c.id IS NOT NULL), '[]') AS categories,
       COALESCE(SUM(i.stock_quantity), 0) AS inventory
FROM products.product p
LEFT JOIN products.products_categories_relations pcr ON p.id = pcr.product_id
LEFT JOIN products.categories c ON pcr.category_id = c.id
LEFT JOIN products.inventories i ON p.id = i.product_id
GROUP BY p.id
`

type GetProductsRow struct {
	ID         uuid.UUID      `json:"id"`
	Name       string         `json:"name"`
	Price      int64          `json:"price"`
	ImageUrl   sql.NullString `json:"image_url"`
	CreatedAt  sql.NullTime   `json:"created_at"`
	UpdatedAt  sql.NullTime   `json:"updated_at"`
	Categories interface{}    `json:"categories"`
	Inventory  interface{}    `json:"inventory"`
}

func (q *Queries) GetProducts(ctx context.Context) ([]GetProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Categories,
			&i.Inventory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postProducts = `-- name: PostProducts :exec
INSERT INTO products.product (id, name, price, image_url)
VALUES ($1, $2, $3, $4)
`

type PostProductsParams struct {
	ID       uuid.UUID      `json:"id"`
	Name     string         `json:"name"`
	Price    int64          `json:"price"`
	ImageUrl sql.NullString `json:"image_url"`
}

func (q *Queries) PostProducts(ctx context.Context, arg PostProductsParams) error {
	_, err := q.db.ExecContext(ctx, postProducts,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.ImageUrl,
	)
	return err
}
